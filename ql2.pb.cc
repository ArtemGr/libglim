// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "ql2.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* VersionDummy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VersionDummy_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* VersionDummy_Version_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Query_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Query_reflection_ = NULL;
const ::google::protobuf::Descriptor* Query_AssocPair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Query_AssocPair_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Query_QueryType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Frame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Frame_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Frame_FrameType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Backtrace_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Backtrace_reflection_ = NULL;
const ::google::protobuf::Descriptor* Response_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Response_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Datum_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Datum_reflection_ = NULL;
const ::google::protobuf::Descriptor* Datum_AssocPair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Datum_AssocPair_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Datum_DatumType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Term_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Term_reflection_ = NULL;
const ::google::protobuf::Descriptor* Term_AssocPair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Term_AssocPair_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Term_TermType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_ql2_2eproto() {
  protobuf_AddDesc_ql2_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "ql2.proto");
  GOOGLE_CHECK(file != NULL);
  VersionDummy_descriptor_ = file->message_type(0);
  static const int VersionDummy_offsets_[1] = {
  };
  VersionDummy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VersionDummy_descriptor_,
      VersionDummy::default_instance_,
      VersionDummy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionDummy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionDummy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VersionDummy));
  VersionDummy_Version_descriptor_ = VersionDummy_descriptor_->enum_type(0);
  Query_descriptor_ = file->message_type(1);
  static const int Query_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, query_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, obsolete_noreply_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, global_optargs_),
  };
  Query_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Query_descriptor_,
      Query::default_instance_,
      Query_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Query));
  Query_AssocPair_descriptor_ = Query_descriptor_->nested_type(0);
  static const int Query_AssocPair_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query_AssocPair, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query_AssocPair, val_),
  };
  Query_AssocPair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Query_AssocPair_descriptor_,
      Query_AssocPair::default_instance_,
      Query_AssocPair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query_AssocPair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Query_AssocPair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Query_AssocPair));
  Query_QueryType_descriptor_ = Query_descriptor_->enum_type(0);
  Frame_descriptor_ = file->message_type(2);
  static const int Frame_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, opt_),
  };
  Frame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Frame_descriptor_,
      Frame::default_instance_,
      Frame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Frame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Frame));
  Frame_FrameType_descriptor_ = Frame_descriptor_->enum_type(0);
  Backtrace_descriptor_ = file->message_type(3);
  static const int Backtrace_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Backtrace, frames_),
  };
  Backtrace_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Backtrace_descriptor_,
      Backtrace::default_instance_,
      Backtrace_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Backtrace, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Backtrace, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Backtrace));
  Response_descriptor_ = file->message_type(4);
  static const int Response_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, token_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, response_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, backtrace_),
  };
  Response_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Response_descriptor_,
      Response::default_instance_,
      Response_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Response, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Response));
  Response_ResponseType_descriptor_ = Response_descriptor_->enum_type(0);
  Datum_descriptor_ = file->message_type(5);
  static const int Datum_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, r_bool_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, r_num_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, r_str_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, r_array_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, r_object_),
  };
  Datum_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Datum_descriptor_,
      Datum::default_instance_,
      Datum_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, _unknown_fields_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum, _extensions_),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Datum));
  Datum_AssocPair_descriptor_ = Datum_descriptor_->nested_type(0);
  static const int Datum_AssocPair_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum_AssocPair, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum_AssocPair, val_),
  };
  Datum_AssocPair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Datum_AssocPair_descriptor_,
      Datum_AssocPair::default_instance_,
      Datum_AssocPair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum_AssocPair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Datum_AssocPair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Datum_AssocPair));
  Datum_DatumType_descriptor_ = Datum_descriptor_->enum_type(0);
  Term_descriptor_ = file->message_type(6);
  static const int Term_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, datum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, args_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, optargs_),
  };
  Term_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Term_descriptor_,
      Term::default_instance_,
      Term_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, _unknown_fields_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term, _extensions_),
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Term));
  Term_AssocPair_descriptor_ = Term_descriptor_->nested_type(0);
  static const int Term_AssocPair_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term_AssocPair, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term_AssocPair, val_),
  };
  Term_AssocPair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Term_AssocPair_descriptor_,
      Term_AssocPair::default_instance_,
      Term_AssocPair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term_AssocPair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Term_AssocPair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Term_AssocPair));
  Term_TermType_descriptor_ = Term_descriptor_->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_ql2_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VersionDummy_descriptor_, &VersionDummy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Query_descriptor_, &Query::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Query_AssocPair_descriptor_, &Query_AssocPair::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Frame_descriptor_, &Frame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Backtrace_descriptor_, &Backtrace::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Response_descriptor_, &Response::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Datum_descriptor_, &Datum::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Datum_AssocPair_descriptor_, &Datum_AssocPair::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Term_descriptor_, &Term::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Term_AssocPair_descriptor_, &Term_AssocPair::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_ql2_2eproto() {
  delete VersionDummy::default_instance_;
  delete VersionDummy_reflection_;
  delete Query::default_instance_;
  delete Query_reflection_;
  delete Query_AssocPair::default_instance_;
  delete Query_AssocPair_reflection_;
  delete Frame::default_instance_;
  delete Frame_reflection_;
  delete Backtrace::default_instance_;
  delete Backtrace_reflection_;
  delete Response::default_instance_;
  delete Response_reflection_;
  delete Datum::default_instance_;
  delete Datum_reflection_;
  delete Datum_AssocPair::default_instance_;
  delete Datum_AssocPair_reflection_;
  delete Term::default_instance_;
  delete Term_reflection_;
  delete Term_AssocPair::default_instance_;
  delete Term_AssocPair_reflection_;
}

void protobuf_AddDesc_ql2_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tql2.proto\"5\n\014VersionDummy\"%\n\007Version\022\014"
    "\n\004V0_1\020\266\364\206\373\003\022\014\n\004V0_2\020\341\203\302\221\007\"\365\001\n\005Query\022\036\n\004"
    "type\030\001 \001(\0162\020.Query.QueryType\022\024\n\005query\030\002 "
    "\001(\0132\005.Term\022\r\n\005token\030\003 \001(\003\022\037\n\020OBSOLETE_no"
    "reply\030\004 \001(\010:\005false\022(\n\016global_optargs\030\006 \003"
    "(\0132\020.Query.AssocPair\032,\n\tAssocPair\022\013\n\003key"
    "\030\001 \001(\t\022\022\n\003val\030\002 \001(\0132\005.Term\".\n\tQueryType\022"
    "\t\n\005START\020\001\022\014\n\010CONTINUE\020\002\022\010\n\004STOP\020\003\"`\n\005Fr"
    "ame\022\036\n\004type\030\001 \001(\0162\020.Frame.FrameType\022\013\n\003p"
    "os\030\002 \001(\003\022\013\n\003opt\030\003 \001(\t\"\035\n\tFrameType\022\007\n\003PO"
    "S\020\001\022\007\n\003OPT\020\002\"#\n\tBacktrace\022\026\n\006frames\030\001 \003("
    "\0132\006.Frame\"\376\001\n\010Response\022$\n\004type\030\001 \001(\0162\026.R"
    "esponse.ResponseType\022\r\n\005token\030\002 \001(\003\022\030\n\010r"
    "esponse\030\003 \003(\0132\006.Datum\022\035\n\tbacktrace\030\004 \001(\013"
    "2\n.Backtrace\"\203\001\n\014ResponseType\022\020\n\014SUCCESS"
    "_ATOM\020\001\022\024\n\020SUCCESS_SEQUENCE\020\002\022\023\n\017SUCCESS"
    "_PARTIAL\020\003\022\020\n\014CLIENT_ERROR\020\020\022\021\n\rCOMPILE_"
    "ERROR\020\021\022\021\n\rRUNTIME_ERROR\020\022\"\240\002\n\005Datum\022\036\n\004"
    "type\030\001 \001(\0162\020.Datum.DatumType\022\016\n\006r_bool\030\002"
    " \001(\010\022\r\n\005r_num\030\003 \001(\001\022\r\n\005r_str\030\004 \001(\t\022\027\n\007r_"
    "array\030\005 \003(\0132\006.Datum\022\"\n\010r_object\030\006 \003(\0132\020."
    "Datum.AssocPair\032-\n\tAssocPair\022\013\n\003key\030\001 \001("
    "\t\022\023\n\003val\030\002 \001(\0132\006.Datum\"T\n\tDatumType\022\n\n\006R"
    "_NULL\020\001\022\n\n\006R_BOOL\020\002\022\t\n\005R_NUM\020\003\022\t\n\005R_STR\020"
    "\004\022\013\n\007R_ARRAY\020\005\022\014\n\010R_OBJECT\020\006*\007\010\220N\020\241\234\001\"\247\n"
    "\n\004Term\022\034\n\004type\030\001 \001(\0162\016.Term.TermType\022\025\n\005"
    "datum\030\002 \001(\0132\006.Datum\022\023\n\004args\030\003 \003(\0132\005.Term"
    "\022 \n\007optargs\030\004 \003(\0132\017.Term.AssocPair\032,\n\tAs"
    "socPair\022\013\n\003key\030\001 \001(\t\022\022\n\003val\030\002 \001(\0132\005.Term"
    "\"\373\010\n\010TermType\022\t\n\005DATUM\020\001\022\016\n\nMAKE_ARRAY\020\002"
    "\022\014\n\010MAKE_OBJ\020\003\022\007\n\003VAR\020\n\022\016\n\nJAVASCRIPT\020\013\022"
    "\t\n\005ERROR\020\014\022\020\n\014IMPLICIT_VAR\020\r\022\006\n\002DB\020\016\022\t\n\005"
    "TABLE\020\017\022\007\n\003GET\020\020\022\013\n\007GET_ALL\020N\022\006\n\002EQ\020\021\022\006\n"
    "\002NE\020\022\022\006\n\002LT\020\023\022\006\n\002LE\020\024\022\006\n\002GT\020\025\022\006\n\002GE\020\026\022\007\n"
    "\003NOT\020\027\022\007\n\003ADD\020\030\022\007\n\003SUB\020\031\022\007\n\003MUL\020\032\022\007\n\003DIV"
    "\020\033\022\007\n\003MOD\020\034\022\n\n\006APPEND\020\035\022\013\n\007PREPEND\020P\022\016\n\n"
    "DIFFERENCE\020_\022\016\n\nSET_INSERT\020X\022\024\n\020SET_INTE"
    "RSECTION\020Y\022\r\n\tSET_UNION\020Z\022\022\n\016SET_DIFFERE"
    "NCE\020[\022\t\n\005SLICE\020\036\022\010\n\004SKIP\020F\022\t\n\005LIMIT\020G\022\016\n"
    "\nINDEXES_OF\020W\022\014\n\010CONTAINS\020]\022\013\n\007GETATTR\020\037"
    "\022\010\n\004KEYS\020^\022\016\n\nHAS_FIELDS\020 \022\017\n\013WITH_FIELD"
    "S\020`\022\t\n\005PLUCK\020!\022\013\n\007WITHOUT\020\"\022\t\n\005MERGE\020#\022\013"
    "\n\007BETWEEN\020$\022\n\n\006REDUCE\020%\022\007\n\003MAP\020&\022\n\n\006FILT"
    "ER\020\'\022\r\n\tCONCATMAP\020(\022\013\n\007ORDERBY\020)\022\014\n\010DIST"
    "INCT\020*\022\t\n\005COUNT\020+\022\014\n\010IS_EMPTY\020V\022\t\n\005UNION"
    "\020,\022\007\n\003NTH\020-\022\026\n\022GROUPED_MAP_REDUCE\020.\022\013\n\007G"
    "ROUPBY\020/\022\016\n\nINNER_JOIN\0200\022\016\n\nOUTER_JOIN\0201"
    "\022\013\n\007EQ_JOIN\0202\022\007\n\003ZIP\020H\022\r\n\tINSERT_AT\020R\022\r\n"
    "\tDELETE_AT\020S\022\r\n\tCHANGE_AT\020T\022\r\n\tSPLICE_AT"
    "\020U\022\r\n\tCOERCE_TO\0203\022\n\n\006TYPEOF\0204\022\n\n\006UPDATE\020"
    "5\022\n\n\006DELETE\0206\022\013\n\007REPLACE\0207\022\n\n\006INSERT\0208\022\r"
    "\n\tDB_CREATE\0209\022\013\n\007DB_DROP\020:\022\013\n\007DB_LIST\020;\022"
    "\020\n\014TABLE_CREATE\020<\022\016\n\nTABLE_DROP\020=\022\016\n\nTAB"
    "LE_LIST\020>\022\020\n\014INDEX_CREATE\020K\022\016\n\nINDEX_DRO"
    "P\020L\022\016\n\nINDEX_LIST\020M\022\013\n\007FUNCALL\020@\022\n\n\006BRAN"
    "CH\020A\022\007\n\003ANY\020B\022\007\n\003ALL\020C\022\013\n\007FOREACH\020D\022\010\n\004F"
    "UNC\020E\022\007\n\003ASC\020I\022\010\n\004DESC\020J\022\010\n\004INFO\020O\022\t\n\005MA"
    "TCH\020a\022\n\n\006SAMPLE\020Q\022\013\n\007DEFAULT\020\\*\007\010\220N\020\241\234\001", 2319);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "ql2.proto", &protobuf_RegisterTypes);
  VersionDummy::default_instance_ = new VersionDummy();
  Query::default_instance_ = new Query();
  Query_AssocPair::default_instance_ = new Query_AssocPair();
  Frame::default_instance_ = new Frame();
  Backtrace::default_instance_ = new Backtrace();
  Response::default_instance_ = new Response();
  Datum::default_instance_ = new Datum();
  Datum_AssocPair::default_instance_ = new Datum_AssocPair();
  Term::default_instance_ = new Term();
  Term_AssocPair::default_instance_ = new Term_AssocPair();
  VersionDummy::default_instance_->InitAsDefaultInstance();
  Query::default_instance_->InitAsDefaultInstance();
  Query_AssocPair::default_instance_->InitAsDefaultInstance();
  Frame::default_instance_->InitAsDefaultInstance();
  Backtrace::default_instance_->InitAsDefaultInstance();
  Response::default_instance_->InitAsDefaultInstance();
  Datum::default_instance_->InitAsDefaultInstance();
  Datum_AssocPair::default_instance_->InitAsDefaultInstance();
  Term::default_instance_->InitAsDefaultInstance();
  Term_AssocPair::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_ql2_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_ql2_2eproto {
  StaticDescriptorInitializer_ql2_2eproto() {
    protobuf_AddDesc_ql2_2eproto();
  }
} static_descriptor_initializer_ql2_2eproto_;


// ===================================================================

const ::google::protobuf::EnumDescriptor* VersionDummy_Version_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionDummy_Version_descriptor_;
}
bool VersionDummy_Version_IsValid(int value) {
  switch(value) {
    case 1063369270:
    case 1915781601:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const VersionDummy_Version VersionDummy::V0_1;
const VersionDummy_Version VersionDummy::V0_2;
const VersionDummy_Version VersionDummy::Version_MIN;
const VersionDummy_Version VersionDummy::Version_MAX;
const int VersionDummy::Version_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
#endif  // !_MSC_VER

VersionDummy::VersionDummy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VersionDummy::InitAsDefaultInstance() {
}

VersionDummy::VersionDummy(const VersionDummy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VersionDummy::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionDummy::~VersionDummy() {
  SharedDtor();
}

void VersionDummy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VersionDummy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VersionDummy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionDummy_descriptor_;
}

const VersionDummy& VersionDummy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ql2_2eproto();  return *default_instance_;
}

VersionDummy* VersionDummy::default_instance_ = NULL;

VersionDummy* VersionDummy::New() const {
  return new VersionDummy;
}

void VersionDummy::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VersionDummy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
  return true;
#undef DO_
}

void VersionDummy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VersionDummy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VersionDummy::ByteSize() const {
  int total_size = 0;
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionDummy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VersionDummy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VersionDummy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VersionDummy::MergeFrom(const VersionDummy& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VersionDummy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionDummy::CopyFrom(const VersionDummy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionDummy::IsInitialized() const {
  
  return true;
}

void VersionDummy::Swap(VersionDummy* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VersionDummy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VersionDummy_descriptor_;
  metadata.reflection = VersionDummy_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Query_QueryType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Query_QueryType_descriptor_;
}
bool Query_QueryType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Query_QueryType Query::START;
const Query_QueryType Query::CONTINUE;
const Query_QueryType Query::STOP;
const Query_QueryType Query::QueryType_MIN;
const Query_QueryType Query::QueryType_MAX;
const int Query::QueryType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Query_AssocPair::kKeyFieldNumber;
const int Query_AssocPair::kValFieldNumber;
#endif  // !_MSC_VER

Query_AssocPair::Query_AssocPair()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Query_AssocPair::InitAsDefaultInstance() {
  val_ = const_cast< ::Term*>(&::Term::default_instance());
}

Query_AssocPair::Query_AssocPair(const Query_AssocPair& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Query_AssocPair::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  val_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Query_AssocPair::~Query_AssocPair() {
  SharedDtor();
}

void Query_AssocPair::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (this != default_instance_) {
    delete val_;
  }
}

void Query_AssocPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Query_AssocPair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Query_AssocPair_descriptor_;
}

const Query_AssocPair& Query_AssocPair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ql2_2eproto();  return *default_instance_;
}

Query_AssocPair* Query_AssocPair::default_instance_ = NULL;

Query_AssocPair* Query_AssocPair::New() const {
  return new Query_AssocPair;
}

void Query_AssocPair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_val()) {
      if (val_ != NULL) val_->::Term::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Query_AssocPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_val;
        break;
      }
      
      // optional .Term val = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_val:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_val()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Query_AssocPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }
  
  // optional .Term val = 2;
  if (has_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->val(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Query_AssocPair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }
  
  // optional .Term val = 2;
  if (has_val()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->val(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Query_AssocPair::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }
    
    // optional .Term val = 2;
    if (has_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->val());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Query_AssocPair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Query_AssocPair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Query_AssocPair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Query_AssocPair::MergeFrom(const Query_AssocPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_val()) {
      mutable_val()->::Term::MergeFrom(from.val());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Query_AssocPair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Query_AssocPair::CopyFrom(const Query_AssocPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Query_AssocPair::IsInitialized() const {
  
  if (has_val()) {
    if (!this->val().IsInitialized()) return false;
  }
  return true;
}

void Query_AssocPair::Swap(Query_AssocPair* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(val_, other->val_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Query_AssocPair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Query_AssocPair_descriptor_;
  metadata.reflection = Query_AssocPair_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Query::kTypeFieldNumber;
const int Query::kQueryFieldNumber;
const int Query::kTokenFieldNumber;
const int Query::kOBSOLETENoreplyFieldNumber;
const int Query::kGlobalOptargsFieldNumber;
#endif  // !_MSC_VER

Query::Query()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Query::InitAsDefaultInstance() {
  query_ = const_cast< ::Term*>(&::Term::default_instance());
}

Query::Query(const Query& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Query::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  query_ = NULL;
  token_ = GOOGLE_LONGLONG(0);
  obsolete_noreply_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Query::~Query() {
  SharedDtor();
}

void Query::SharedDtor() {
  if (this != default_instance_) {
    delete query_;
  }
}

void Query::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Query::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Query_descriptor_;
}

const Query& Query::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ql2_2eproto();  return *default_instance_;
}

Query* Query::default_instance_ = NULL;

Query* Query::New() const {
  return new Query;
}

void Query::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_query()) {
      if (query_ != NULL) query_->::Term::Clear();
    }
    token_ = GOOGLE_LONGLONG(0);
    obsolete_noreply_ = false;
  }
  global_optargs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Query::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Query.QueryType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Query_QueryType_IsValid(value)) {
            set_type(static_cast< ::Query_QueryType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_query;
        break;
      }
      
      // optional .Term query = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_query:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_query()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_token;
        break;
      }
      
      // optional int64 token = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_token:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &token_)));
          set_has_token();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_OBSOLETE_noreply;
        break;
      }
      
      // optional bool OBSOLETE_noreply = 4 [default = false];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_OBSOLETE_noreply:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &obsolete_noreply_)));
          set_has_obsolete_noreply();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_global_optargs;
        break;
      }
      
      // repeated .Query.AssocPair global_optargs = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_global_optargs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_global_optargs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_global_optargs;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Query::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Query.QueryType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .Term query = 2;
  if (has_query()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->query(), output);
  }
  
  // optional int64 token = 3;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->token(), output);
  }
  
  // optional bool OBSOLETE_noreply = 4 [default = false];
  if (has_obsolete_noreply()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->obsolete_noreply(), output);
  }
  
  // repeated .Query.AssocPair global_optargs = 6;
  for (int i = 0; i < this->global_optargs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->global_optargs(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Query::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Query.QueryType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional .Term query = 2;
  if (has_query()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->query(), target);
  }
  
  // optional int64 token = 3;
  if (has_token()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->token(), target);
  }
  
  // optional bool OBSOLETE_noreply = 4 [default = false];
  if (has_obsolete_noreply()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->obsolete_noreply(), target);
  }
  
  // repeated .Query.AssocPair global_optargs = 6;
  for (int i = 0; i < this->global_optargs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->global_optargs(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Query::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Query.QueryType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .Term query = 2;
    if (has_query()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->query());
    }
    
    // optional int64 token = 3;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->token());
    }
    
    // optional bool OBSOLETE_noreply = 4 [default = false];
    if (has_obsolete_noreply()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated .Query.AssocPair global_optargs = 6;
  total_size += 1 * this->global_optargs_size();
  for (int i = 0; i < this->global_optargs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->global_optargs(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Query::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Query* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Query*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Query::MergeFrom(const Query& from) {
  GOOGLE_CHECK_NE(&from, this);
  global_optargs_.MergeFrom(from.global_optargs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_query()) {
      mutable_query()->::Term::MergeFrom(from.query());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_obsolete_noreply()) {
      set_obsolete_noreply(from.obsolete_noreply());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Query::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Query::CopyFrom(const Query& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Query::IsInitialized() const {
  
  if (has_query()) {
    if (!this->query().IsInitialized()) return false;
  }
  for (int i = 0; i < global_optargs_size(); i++) {
    if (!this->global_optargs(i).IsInitialized()) return false;
  }
  return true;
}

void Query::Swap(Query* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(query_, other->query_);
    std::swap(token_, other->token_);
    std::swap(obsolete_noreply_, other->obsolete_noreply_);
    global_optargs_.Swap(&other->global_optargs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Query::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Query_descriptor_;
  metadata.reflection = Query_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Frame_FrameType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Frame_FrameType_descriptor_;
}
bool Frame_FrameType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Frame_FrameType Frame::POS;
const Frame_FrameType Frame::OPT;
const Frame_FrameType Frame::FrameType_MIN;
const Frame_FrameType Frame::FrameType_MAX;
const int Frame::FrameType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Frame::kTypeFieldNumber;
const int Frame::kPosFieldNumber;
const int Frame::kOptFieldNumber;
#endif  // !_MSC_VER

Frame::Frame()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Frame::InitAsDefaultInstance() {
}

Frame::Frame(const Frame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Frame::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  pos_ = GOOGLE_LONGLONG(0);
  opt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Frame::~Frame() {
  SharedDtor();
}

void Frame::SharedDtor() {
  if (opt_ != &::google::protobuf::internal::kEmptyString) {
    delete opt_;
  }
  if (this != default_instance_) {
  }
}

void Frame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Frame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Frame_descriptor_;
}

const Frame& Frame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ql2_2eproto();  return *default_instance_;
}

Frame* Frame::default_instance_ = NULL;

Frame* Frame::New() const {
  return new Frame;
}

void Frame::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    pos_ = GOOGLE_LONGLONG(0);
    if (has_opt()) {
      if (opt_ != &::google::protobuf::internal::kEmptyString) {
        opt_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Frame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Frame.FrameType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Frame_FrameType_IsValid(value)) {
            set_type(static_cast< ::Frame_FrameType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_pos;
        break;
      }
      
      // optional int64 pos = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_pos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &pos_)));
          set_has_pos();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_opt;
        break;
      }
      
      // optional string opt = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_opt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_opt()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->opt().data(), this->opt().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Frame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Frame.FrameType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional int64 pos = 2;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->pos(), output);
  }
  
  // optional string opt = 3;
  if (has_opt()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->opt().data(), this->opt().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->opt(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Frame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Frame.FrameType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional int64 pos = 2;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->pos(), target);
  }
  
  // optional string opt = 3;
  if (has_opt()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->opt().data(), this->opt().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->opt(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Frame::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Frame.FrameType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional int64 pos = 2;
    if (has_pos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->pos());
    }
    
    // optional string opt = 3;
    if (has_opt()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->opt());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Frame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Frame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Frame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Frame::MergeFrom(const Frame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_pos()) {
      set_pos(from.pos());
    }
    if (from.has_opt()) {
      set_opt(from.opt());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Frame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Frame::CopyFrom(const Frame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  
  return true;
}

void Frame::Swap(Frame* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(pos_, other->pos_);
    std::swap(opt_, other->opt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Frame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Frame_descriptor_;
  metadata.reflection = Frame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Backtrace::kFramesFieldNumber;
#endif  // !_MSC_VER

Backtrace::Backtrace()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Backtrace::InitAsDefaultInstance() {
}

Backtrace::Backtrace(const Backtrace& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Backtrace::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Backtrace::~Backtrace() {
  SharedDtor();
}

void Backtrace::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Backtrace::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Backtrace::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Backtrace_descriptor_;
}

const Backtrace& Backtrace::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ql2_2eproto();  return *default_instance_;
}

Backtrace* Backtrace::default_instance_ = NULL;

Backtrace* Backtrace::New() const {
  return new Backtrace;
}

void Backtrace::Clear() {
  frames_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Backtrace::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Frame frames = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_frames:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frames()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_frames;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Backtrace::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Frame frames = 1;
  for (int i = 0; i < this->frames_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->frames(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Backtrace::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Frame frames = 1;
  for (int i = 0; i < this->frames_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->frames(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Backtrace::ByteSize() const {
  int total_size = 0;
  
  // repeated .Frame frames = 1;
  total_size += 1 * this->frames_size();
  for (int i = 0; i < this->frames_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frames(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Backtrace::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Backtrace* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Backtrace*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Backtrace::MergeFrom(const Backtrace& from) {
  GOOGLE_CHECK_NE(&from, this);
  frames_.MergeFrom(from.frames_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Backtrace::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Backtrace::CopyFrom(const Backtrace& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Backtrace::IsInitialized() const {
  
  return true;
}

void Backtrace::Swap(Backtrace* other) {
  if (other != this) {
    frames_.Swap(&other->frames_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Backtrace::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Backtrace_descriptor_;
  metadata.reflection = Backtrace_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Response_ResponseType_descriptor_;
}
bool Response_ResponseType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Response_ResponseType Response::SUCCESS_ATOM;
const Response_ResponseType Response::SUCCESS_SEQUENCE;
const Response_ResponseType Response::SUCCESS_PARTIAL;
const Response_ResponseType Response::CLIENT_ERROR;
const Response_ResponseType Response::COMPILE_ERROR;
const Response_ResponseType Response::RUNTIME_ERROR;
const Response_ResponseType Response::ResponseType_MIN;
const Response_ResponseType Response::ResponseType_MAX;
const int Response::ResponseType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Response::kTypeFieldNumber;
const int Response::kTokenFieldNumber;
const int Response::kResponseFieldNumber;
const int Response::kBacktraceFieldNumber;
#endif  // !_MSC_VER

Response::Response()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Response::InitAsDefaultInstance() {
  backtrace_ = const_cast< ::Backtrace*>(&::Backtrace::default_instance());
}

Response::Response(const Response& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Response::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  token_ = GOOGLE_LONGLONG(0);
  backtrace_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Response::~Response() {
  SharedDtor();
}

void Response::SharedDtor() {
  if (this != default_instance_) {
    delete backtrace_;
  }
}

void Response::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Response::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Response_descriptor_;
}

const Response& Response::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ql2_2eproto();  return *default_instance_;
}

Response* Response::default_instance_ = NULL;

Response* Response::New() const {
  return new Response;
}

void Response::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    token_ = GOOGLE_LONGLONG(0);
    if (has_backtrace()) {
      if (backtrace_ != NULL) backtrace_->::Backtrace::Clear();
    }
  }
  response_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Response::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Response.ResponseType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Response_ResponseType_IsValid(value)) {
            set_type(static_cast< ::Response_ResponseType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_token;
        break;
      }
      
      // optional int64 token = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_token:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &token_)));
          set_has_token();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_response;
        break;
      }
      
      // repeated .Datum response = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_response:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_response()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_response;
        if (input->ExpectTag(34)) goto parse_backtrace;
        break;
      }
      
      // optional .Backtrace backtrace = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_backtrace:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_backtrace()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Response::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Response.ResponseType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional int64 token = 2;
  if (has_token()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->token(), output);
  }
  
  // repeated .Datum response = 3;
  for (int i = 0; i < this->response_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->response(i), output);
  }
  
  // optional .Backtrace backtrace = 4;
  if (has_backtrace()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->backtrace(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Response::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Response.ResponseType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional int64 token = 2;
  if (has_token()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->token(), target);
  }
  
  // repeated .Datum response = 3;
  for (int i = 0; i < this->response_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->response(i), target);
  }
  
  // optional .Backtrace backtrace = 4;
  if (has_backtrace()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->backtrace(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Response::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Response.ResponseType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional int64 token = 2;
    if (has_token()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->token());
    }
    
    // optional .Backtrace backtrace = 4;
    if (has_backtrace()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->backtrace());
    }
    
  }
  // repeated .Datum response = 3;
  total_size += 1 * this->response_size();
  for (int i = 0; i < this->response_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->response(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Response::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Response* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Response*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Response::MergeFrom(const Response& from) {
  GOOGLE_CHECK_NE(&from, this);
  response_.MergeFrom(from.response_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_token()) {
      set_token(from.token());
    }
    if (from.has_backtrace()) {
      mutable_backtrace()->::Backtrace::MergeFrom(from.backtrace());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Response::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Response::CopyFrom(const Response& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Response::IsInitialized() const {
  
  for (int i = 0; i < response_size(); i++) {
    if (!this->response(i).IsInitialized()) return false;
  }
  return true;
}

void Response::Swap(Response* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(token_, other->token_);
    response_.Swap(&other->response_);
    std::swap(backtrace_, other->backtrace_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Response::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Response_descriptor_;
  metadata.reflection = Response_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Datum_DatumType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Datum_DatumType_descriptor_;
}
bool Datum_DatumType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Datum_DatumType Datum::R_NULL;
const Datum_DatumType Datum::R_BOOL;
const Datum_DatumType Datum::R_NUM;
const Datum_DatumType Datum::R_STR;
const Datum_DatumType Datum::R_ARRAY;
const Datum_DatumType Datum::R_OBJECT;
const Datum_DatumType Datum::DatumType_MIN;
const Datum_DatumType Datum::DatumType_MAX;
const int Datum::DatumType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Datum_AssocPair::kKeyFieldNumber;
const int Datum_AssocPair::kValFieldNumber;
#endif  // !_MSC_VER

Datum_AssocPair::Datum_AssocPair()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Datum_AssocPair::InitAsDefaultInstance() {
  val_ = const_cast< ::Datum*>(&::Datum::default_instance());
}

Datum_AssocPair::Datum_AssocPair(const Datum_AssocPair& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Datum_AssocPair::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  val_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Datum_AssocPair::~Datum_AssocPair() {
  SharedDtor();
}

void Datum_AssocPair::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (this != default_instance_) {
    delete val_;
  }
}

void Datum_AssocPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Datum_AssocPair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Datum_AssocPair_descriptor_;
}

const Datum_AssocPair& Datum_AssocPair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ql2_2eproto();  return *default_instance_;
}

Datum_AssocPair* Datum_AssocPair::default_instance_ = NULL;

Datum_AssocPair* Datum_AssocPair::New() const {
  return new Datum_AssocPair;
}

void Datum_AssocPair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_val()) {
      if (val_ != NULL) val_->::Datum::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Datum_AssocPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_val;
        break;
      }
      
      // optional .Datum val = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_val:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_val()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Datum_AssocPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }
  
  // optional .Datum val = 2;
  if (has_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->val(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Datum_AssocPair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }
  
  // optional .Datum val = 2;
  if (has_val()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->val(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Datum_AssocPair::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }
    
    // optional .Datum val = 2;
    if (has_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->val());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Datum_AssocPair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Datum_AssocPair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Datum_AssocPair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Datum_AssocPair::MergeFrom(const Datum_AssocPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_val()) {
      mutable_val()->::Datum::MergeFrom(from.val());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Datum_AssocPair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Datum_AssocPair::CopyFrom(const Datum_AssocPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Datum_AssocPair::IsInitialized() const {
  
  if (has_val()) {
    if (!this->val().IsInitialized()) return false;
  }
  return true;
}

void Datum_AssocPair::Swap(Datum_AssocPair* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(val_, other->val_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Datum_AssocPair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Datum_AssocPair_descriptor_;
  metadata.reflection = Datum_AssocPair_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Datum::kTypeFieldNumber;
const int Datum::kRBoolFieldNumber;
const int Datum::kRNumFieldNumber;
const int Datum::kRStrFieldNumber;
const int Datum::kRArrayFieldNumber;
const int Datum::kRObjectFieldNumber;
#endif  // !_MSC_VER

Datum::Datum()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Datum::InitAsDefaultInstance() {
}

Datum::Datum(const Datum& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Datum::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  r_bool_ = false;
  r_num_ = 0;
  r_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Datum::~Datum() {
  SharedDtor();
}

void Datum::SharedDtor() {
  if (r_str_ != &::google::protobuf::internal::kEmptyString) {
    delete r_str_;
  }
  if (this != default_instance_) {
  }
}

void Datum::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Datum::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Datum_descriptor_;
}

const Datum& Datum::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ql2_2eproto();  return *default_instance_;
}

Datum* Datum::default_instance_ = NULL;

Datum* Datum::New() const {
  return new Datum;
}

void Datum::Clear() {
  _extensions_.Clear();
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    r_bool_ = false;
    r_num_ = 0;
    if (has_r_str()) {
      if (r_str_ != &::google::protobuf::internal::kEmptyString) {
        r_str_->clear();
      }
    }
  }
  r_array_.Clear();
  r_object_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Datum::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Datum.DatumType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Datum_DatumType_IsValid(value)) {
            set_type(static_cast< ::Datum_DatumType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_r_bool;
        break;
      }
      
      // optional bool r_bool = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_r_bool:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &r_bool_)));
          set_has_r_bool();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_r_num;
        break;
      }
      
      // optional double r_num = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_r_num:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &r_num_)));
          set_has_r_num();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_r_str;
        break;
      }
      
      // optional string r_str = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_r_str:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_r_str()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->r_str().data(), this->r_str().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_r_array;
        break;
      }
      
      // repeated .Datum r_array = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_r_array:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_r_array()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_r_array;
        if (input->ExpectTag(50)) goto parse_r_object;
        break;
      }
      
      // repeated .Datum.AssocPair r_object = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_r_object:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_r_object()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_r_object;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        if ((80000u <= tag && tag < 160008u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Datum::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Datum.DatumType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional bool r_bool = 2;
  if (has_r_bool()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->r_bool(), output);
  }
  
  // optional double r_num = 3;
  if (has_r_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->r_num(), output);
  }
  
  // optional string r_str = 4;
  if (has_r_str()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->r_str().data(), this->r_str().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->r_str(), output);
  }
  
  // repeated .Datum r_array = 5;
  for (int i = 0; i < this->r_array_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->r_array(i), output);
  }
  
  // repeated .Datum.AssocPair r_object = 6;
  for (int i = 0; i < this->r_object_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->r_object(i), output);
  }
  
  // Extension range [10000, 20001)
  _extensions_.SerializeWithCachedSizes(
      10000, 20001, output);
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Datum::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Datum.DatumType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional bool r_bool = 2;
  if (has_r_bool()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->r_bool(), target);
  }
  
  // optional double r_num = 3;
  if (has_r_num()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->r_num(), target);
  }
  
  // optional string r_str = 4;
  if (has_r_str()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->r_str().data(), this->r_str().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->r_str(), target);
  }
  
  // repeated .Datum r_array = 5;
  for (int i = 0; i < this->r_array_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->r_array(i), target);
  }
  
  // repeated .Datum.AssocPair r_object = 6;
  for (int i = 0; i < this->r_object_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->r_object(i), target);
  }
  
  // Extension range [10000, 20001)
  target = _extensions_.SerializeWithCachedSizesToArray(
      10000, 20001, target);
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Datum::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Datum.DatumType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional bool r_bool = 2;
    if (has_r_bool()) {
      total_size += 1 + 1;
    }
    
    // optional double r_num = 3;
    if (has_r_num()) {
      total_size += 1 + 8;
    }
    
    // optional string r_str = 4;
    if (has_r_str()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->r_str());
    }
    
  }
  // repeated .Datum r_array = 5;
  total_size += 1 * this->r_array_size();
  for (int i = 0; i < this->r_array_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->r_array(i));
  }
  
  // repeated .Datum.AssocPair r_object = 6;
  total_size += 1 * this->r_object_size();
  for (int i = 0; i < this->r_object_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->r_object(i));
  }
  
  total_size += _extensions_.ByteSize();
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Datum::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Datum* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Datum*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Datum::MergeFrom(const Datum& from) {
  GOOGLE_CHECK_NE(&from, this);
  r_array_.MergeFrom(from.r_array_);
  r_object_.MergeFrom(from.r_object_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_r_bool()) {
      set_r_bool(from.r_bool());
    }
    if (from.has_r_num()) {
      set_r_num(from.r_num());
    }
    if (from.has_r_str()) {
      set_r_str(from.r_str());
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Datum::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Datum::CopyFrom(const Datum& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Datum::IsInitialized() const {
  
  for (int i = 0; i < r_array_size(); i++) {
    if (!this->r_array(i).IsInitialized()) return false;
  }
  for (int i = 0; i < r_object_size(); i++) {
    if (!this->r_object(i).IsInitialized()) return false;
  }
  
  if (!_extensions_.IsInitialized()) return false;  return true;
}

void Datum::Swap(Datum* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(r_bool_, other->r_bool_);
    std::swap(r_num_, other->r_num_);
    std::swap(r_str_, other->r_str_);
    r_array_.Swap(&other->r_array_);
    r_object_.Swap(&other->r_object_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
    _extensions_.Swap(&other->_extensions_);
  }
}

::google::protobuf::Metadata Datum::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Datum_descriptor_;
  metadata.reflection = Datum_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Term_TermType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Term_TermType_descriptor_;
}
bool Term_TermType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 79:
    case 80:
    case 81:
    case 82:
    case 83:
    case 84:
    case 85:
    case 86:
    case 87:
    case 88:
    case 89:
    case 90:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Term_TermType Term::DATUM;
const Term_TermType Term::MAKE_ARRAY;
const Term_TermType Term::MAKE_OBJ;
const Term_TermType Term::VAR;
const Term_TermType Term::JAVASCRIPT;
const Term_TermType Term::ERROR;
const Term_TermType Term::IMPLICIT_VAR;
const Term_TermType Term::DB;
const Term_TermType Term::TABLE;
const Term_TermType Term::GET;
const Term_TermType Term::GET_ALL;
const Term_TermType Term::EQ;
const Term_TermType Term::NE;
const Term_TermType Term::LT;
const Term_TermType Term::LE;
const Term_TermType Term::GT;
const Term_TermType Term::GE;
const Term_TermType Term::NOT;
const Term_TermType Term::ADD;
const Term_TermType Term::SUB;
const Term_TermType Term::MUL;
const Term_TermType Term::DIV;
const Term_TermType Term::MOD;
const Term_TermType Term::APPEND;
const Term_TermType Term::PREPEND;
const Term_TermType Term::DIFFERENCE;
const Term_TermType Term::SET_INSERT;
const Term_TermType Term::SET_INTERSECTION;
const Term_TermType Term::SET_UNION;
const Term_TermType Term::SET_DIFFERENCE;
const Term_TermType Term::SLICE;
const Term_TermType Term::SKIP;
const Term_TermType Term::LIMIT;
const Term_TermType Term::INDEXES_OF;
const Term_TermType Term::CONTAINS;
const Term_TermType Term::GETATTR;
const Term_TermType Term::KEYS;
const Term_TermType Term::HAS_FIELDS;
const Term_TermType Term::WITH_FIELDS;
const Term_TermType Term::PLUCK;
const Term_TermType Term::WITHOUT;
const Term_TermType Term::MERGE;
const Term_TermType Term::BETWEEN;
const Term_TermType Term::REDUCE;
const Term_TermType Term::MAP;
const Term_TermType Term::FILTER;
const Term_TermType Term::CONCATMAP;
const Term_TermType Term::ORDERBY;
const Term_TermType Term::DISTINCT;
const Term_TermType Term::COUNT;
const Term_TermType Term::IS_EMPTY;
const Term_TermType Term::UNION;
const Term_TermType Term::NTH;
const Term_TermType Term::GROUPED_MAP_REDUCE;
const Term_TermType Term::GROUPBY;
const Term_TermType Term::INNER_JOIN;
const Term_TermType Term::OUTER_JOIN;
const Term_TermType Term::EQ_JOIN;
const Term_TermType Term::ZIP;
const Term_TermType Term::INSERT_AT;
const Term_TermType Term::DELETE_AT;
const Term_TermType Term::CHANGE_AT;
const Term_TermType Term::SPLICE_AT;
const Term_TermType Term::COERCE_TO;
const Term_TermType Term::TYPEOF;
const Term_TermType Term::UPDATE;
const Term_TermType Term::DELETE;
const Term_TermType Term::REPLACE;
const Term_TermType Term::INSERT;
const Term_TermType Term::DB_CREATE;
const Term_TermType Term::DB_DROP;
const Term_TermType Term::DB_LIST;
const Term_TermType Term::TABLE_CREATE;
const Term_TermType Term::TABLE_DROP;
const Term_TermType Term::TABLE_LIST;
const Term_TermType Term::INDEX_CREATE;
const Term_TermType Term::INDEX_DROP;
const Term_TermType Term::INDEX_LIST;
const Term_TermType Term::FUNCALL;
const Term_TermType Term::BRANCH;
const Term_TermType Term::ANY;
const Term_TermType Term::ALL;
const Term_TermType Term::FOREACH;
const Term_TermType Term::FUNC;
const Term_TermType Term::ASC;
const Term_TermType Term::DESC;
const Term_TermType Term::INFO;
const Term_TermType Term::MATCH;
const Term_TermType Term::SAMPLE;
const Term_TermType Term::DEFAULT;
const Term_TermType Term::TermType_MIN;
const Term_TermType Term::TermType_MAX;
const int Term::TermType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Term_AssocPair::kKeyFieldNumber;
const int Term_AssocPair::kValFieldNumber;
#endif  // !_MSC_VER

Term_AssocPair::Term_AssocPair()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Term_AssocPair::InitAsDefaultInstance() {
  val_ = const_cast< ::Term*>(&::Term::default_instance());
}

Term_AssocPair::Term_AssocPair(const Term_AssocPair& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Term_AssocPair::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  val_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Term_AssocPair::~Term_AssocPair() {
  SharedDtor();
}

void Term_AssocPair::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (this != default_instance_) {
    delete val_;
  }
}

void Term_AssocPair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Term_AssocPair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Term_AssocPair_descriptor_;
}

const Term_AssocPair& Term_AssocPair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ql2_2eproto();  return *default_instance_;
}

Term_AssocPair* Term_AssocPair::default_instance_ = NULL;

Term_AssocPair* Term_AssocPair::New() const {
  return new Term_AssocPair;
}

void Term_AssocPair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_val()) {
      if (val_ != NULL) val_->::Term::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Term_AssocPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_val;
        break;
      }
      
      // optional .Term val = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_val:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_val()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Term_AssocPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }
  
  // optional .Term val = 2;
  if (has_val()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->val(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Term_AssocPair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }
  
  // optional .Term val = 2;
  if (has_val()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->val(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Term_AssocPair::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }
    
    // optional .Term val = 2;
    if (has_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->val());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Term_AssocPair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Term_AssocPair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Term_AssocPair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Term_AssocPair::MergeFrom(const Term_AssocPair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_val()) {
      mutable_val()->::Term::MergeFrom(from.val());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Term_AssocPair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Term_AssocPair::CopyFrom(const Term_AssocPair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Term_AssocPair::IsInitialized() const {
  
  if (has_val()) {
    if (!this->val().IsInitialized()) return false;
  }
  return true;
}

void Term_AssocPair::Swap(Term_AssocPair* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(val_, other->val_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Term_AssocPair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Term_AssocPair_descriptor_;
  metadata.reflection = Term_AssocPair_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Term::kTypeFieldNumber;
const int Term::kDatumFieldNumber;
const int Term::kArgsFieldNumber;
const int Term::kOptargsFieldNumber;
#endif  // !_MSC_VER

Term::Term()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Term::InitAsDefaultInstance() {
  datum_ = const_cast< ::Datum*>(&::Datum::default_instance());
}

Term::Term(const Term& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Term::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  datum_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Term::~Term() {
  SharedDtor();
}

void Term::SharedDtor() {
  if (this != default_instance_) {
    delete datum_;
  }
}

void Term::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Term::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Term_descriptor_;
}

const Term& Term::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_ql2_2eproto();  return *default_instance_;
}

Term* Term::default_instance_ = NULL;

Term* Term::New() const {
  return new Term;
}

void Term::Clear() {
  _extensions_.Clear();
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
    if (has_datum()) {
      if (datum_ != NULL) datum_->::Datum::Clear();
    }
  }
  args_.Clear();
  optargs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Term::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Term.TermType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Term_TermType_IsValid(value)) {
            set_type(static_cast< ::Term_TermType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_datum;
        break;
      }
      
      // optional .Datum datum = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_datum:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_datum()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_args;
        break;
      }
      
      // repeated .Term args = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_args:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_args()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_args;
        if (input->ExpectTag(34)) goto parse_optargs;
        break;
      }
      
      // repeated .Term.AssocPair optargs = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_optargs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_optargs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_optargs;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        if ((80000u <= tag && tag < 160008u)) {
          DO_(_extensions_.ParseField(tag, input, default_instance_,
                                      mutable_unknown_fields()));
          continue;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Term::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Term.TermType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }
  
  // optional .Datum datum = 2;
  if (has_datum()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->datum(), output);
  }
  
  // repeated .Term args = 3;
  for (int i = 0; i < this->args_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->args(i), output);
  }
  
  // repeated .Term.AssocPair optargs = 4;
  for (int i = 0; i < this->optargs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->optargs(i), output);
  }
  
  // Extension range [10000, 20001)
  _extensions_.SerializeWithCachedSizes(
      10000, 20001, output);
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Term::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Term.TermType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }
  
  // optional .Datum datum = 2;
  if (has_datum()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->datum(), target);
  }
  
  // repeated .Term args = 3;
  for (int i = 0; i < this->args_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->args(i), target);
  }
  
  // repeated .Term.AssocPair optargs = 4;
  for (int i = 0; i < this->optargs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->optargs(i), target);
  }
  
  // Extension range [10000, 20001)
  target = _extensions_.SerializeWithCachedSizesToArray(
      10000, 20001, target);
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Term::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Term.TermType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }
    
    // optional .Datum datum = 2;
    if (has_datum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->datum());
    }
    
  }
  // repeated .Term args = 3;
  total_size += 1 * this->args_size();
  for (int i = 0; i < this->args_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->args(i));
  }
  
  // repeated .Term.AssocPair optargs = 4;
  total_size += 1 * this->optargs_size();
  for (int i = 0; i < this->optargs_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->optargs(i));
  }
  
  total_size += _extensions_.ByteSize();
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Term::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Term* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Term*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Term::MergeFrom(const Term& from) {
  GOOGLE_CHECK_NE(&from, this);
  args_.MergeFrom(from.args_);
  optargs_.MergeFrom(from.optargs_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_datum()) {
      mutable_datum()->::Datum::MergeFrom(from.datum());
    }
  }
  _extensions_.MergeFrom(from._extensions_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Term::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Term::CopyFrom(const Term& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Term::IsInitialized() const {
  
  if (has_datum()) {
    if (!this->datum().IsInitialized()) return false;
  }
  for (int i = 0; i < args_size(); i++) {
    if (!this->args(i).IsInitialized()) return false;
  }
  for (int i = 0; i < optargs_size(); i++) {
    if (!this->optargs(i).IsInitialized()) return false;
  }
  
  if (!_extensions_.IsInitialized()) return false;  return true;
}

void Term::Swap(Term* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(datum_, other->datum_);
    args_.Swap(&other->args_);
    optargs_.Swap(&other->optargs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
    _extensions_.Swap(&other->_extensions_);
  }
}

::google::protobuf::Metadata Term::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Term_descriptor_;
  metadata.reflection = Term_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
