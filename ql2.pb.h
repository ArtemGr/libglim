// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ql2.proto

#ifndef PROTOBUF_ql2_2eproto__INCLUDED
#define PROTOBUF_ql2_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ql2_2eproto();
void protobuf_AssignDesc_ql2_2eproto();
void protobuf_ShutdownFile_ql2_2eproto();

class VersionDummy;
class Query;
class Query_AssocPair;
class Frame;
class Backtrace;
class Response;
class Datum;
class Datum_AssocPair;
class Term;
class Term_AssocPair;

enum VersionDummy_Version {
  VersionDummy_Version_V0_1 = 1063369270,
  VersionDummy_Version_V0_2 = 1915781601
};
bool VersionDummy_Version_IsValid(int value);
const VersionDummy_Version VersionDummy_Version_Version_MIN = VersionDummy_Version_V0_1;
const VersionDummy_Version VersionDummy_Version_Version_MAX = VersionDummy_Version_V0_2;
const int VersionDummy_Version_Version_ARRAYSIZE = VersionDummy_Version_Version_MAX + 1;

const ::google::protobuf::EnumDescriptor* VersionDummy_Version_descriptor();
inline const ::std::string& VersionDummy_Version_Name(VersionDummy_Version value) {
  return ::google::protobuf::internal::NameOfEnum(
    VersionDummy_Version_descriptor(), value);
}
inline bool VersionDummy_Version_Parse(
    const ::std::string& name, VersionDummy_Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VersionDummy_Version>(
    VersionDummy_Version_descriptor(), name, value);
}
enum Query_QueryType {
  Query_QueryType_START = 1,
  Query_QueryType_CONTINUE = 2,
  Query_QueryType_STOP = 3
};
bool Query_QueryType_IsValid(int value);
const Query_QueryType Query_QueryType_QueryType_MIN = Query_QueryType_START;
const Query_QueryType Query_QueryType_QueryType_MAX = Query_QueryType_STOP;
const int Query_QueryType_QueryType_ARRAYSIZE = Query_QueryType_QueryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Query_QueryType_descriptor();
inline const ::std::string& Query_QueryType_Name(Query_QueryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Query_QueryType_descriptor(), value);
}
inline bool Query_QueryType_Parse(
    const ::std::string& name, Query_QueryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Query_QueryType>(
    Query_QueryType_descriptor(), name, value);
}
enum Frame_FrameType {
  Frame_FrameType_POS = 1,
  Frame_FrameType_OPT = 2
};
bool Frame_FrameType_IsValid(int value);
const Frame_FrameType Frame_FrameType_FrameType_MIN = Frame_FrameType_POS;
const Frame_FrameType Frame_FrameType_FrameType_MAX = Frame_FrameType_OPT;
const int Frame_FrameType_FrameType_ARRAYSIZE = Frame_FrameType_FrameType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Frame_FrameType_descriptor();
inline const ::std::string& Frame_FrameType_Name(Frame_FrameType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Frame_FrameType_descriptor(), value);
}
inline bool Frame_FrameType_Parse(
    const ::std::string& name, Frame_FrameType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Frame_FrameType>(
    Frame_FrameType_descriptor(), name, value);
}
enum Response_ResponseType {
  Response_ResponseType_SUCCESS_ATOM = 1,
  Response_ResponseType_SUCCESS_SEQUENCE = 2,
  Response_ResponseType_SUCCESS_PARTIAL = 3,
  Response_ResponseType_CLIENT_ERROR = 16,
  Response_ResponseType_COMPILE_ERROR = 17,
  Response_ResponseType_RUNTIME_ERROR = 18
};
bool Response_ResponseType_IsValid(int value);
const Response_ResponseType Response_ResponseType_ResponseType_MIN = Response_ResponseType_SUCCESS_ATOM;
const Response_ResponseType Response_ResponseType_ResponseType_MAX = Response_ResponseType_RUNTIME_ERROR;
const int Response_ResponseType_ResponseType_ARRAYSIZE = Response_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor();
inline const ::std::string& Response_ResponseType_Name(Response_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ResponseType_descriptor(), value);
}
inline bool Response_ResponseType_Parse(
    const ::std::string& name, Response_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ResponseType>(
    Response_ResponseType_descriptor(), name, value);
}
enum Datum_DatumType {
  Datum_DatumType_R_NULL = 1,
  Datum_DatumType_R_BOOL = 2,
  Datum_DatumType_R_NUM = 3,
  Datum_DatumType_R_STR = 4,
  Datum_DatumType_R_ARRAY = 5,
  Datum_DatumType_R_OBJECT = 6
};
bool Datum_DatumType_IsValid(int value);
const Datum_DatumType Datum_DatumType_DatumType_MIN = Datum_DatumType_R_NULL;
const Datum_DatumType Datum_DatumType_DatumType_MAX = Datum_DatumType_R_OBJECT;
const int Datum_DatumType_DatumType_ARRAYSIZE = Datum_DatumType_DatumType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Datum_DatumType_descriptor();
inline const ::std::string& Datum_DatumType_Name(Datum_DatumType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Datum_DatumType_descriptor(), value);
}
inline bool Datum_DatumType_Parse(
    const ::std::string& name, Datum_DatumType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Datum_DatumType>(
    Datum_DatumType_descriptor(), name, value);
}
enum Term_TermType {
  Term_TermType_DATUM = 1,
  Term_TermType_MAKE_ARRAY = 2,
  Term_TermType_MAKE_OBJ = 3,
  Term_TermType_VAR = 10,
  Term_TermType_JAVASCRIPT = 11,
  Term_TermType_ERROR = 12,
  Term_TermType_IMPLICIT_VAR = 13,
  Term_TermType_DB = 14,
  Term_TermType_TABLE = 15,
  Term_TermType_GET = 16,
  Term_TermType_GET_ALL = 78,
  Term_TermType_EQ = 17,
  Term_TermType_NE = 18,
  Term_TermType_LT = 19,
  Term_TermType_LE = 20,
  Term_TermType_GT = 21,
  Term_TermType_GE = 22,
  Term_TermType_NOT = 23,
  Term_TermType_ADD = 24,
  Term_TermType_SUB = 25,
  Term_TermType_MUL = 26,
  Term_TermType_DIV = 27,
  Term_TermType_MOD = 28,
  Term_TermType_APPEND = 29,
  Term_TermType_PREPEND = 80,
  Term_TermType_DIFFERENCE = 95,
  Term_TermType_SET_INSERT = 88,
  Term_TermType_SET_INTERSECTION = 89,
  Term_TermType_SET_UNION = 90,
  Term_TermType_SET_DIFFERENCE = 91,
  Term_TermType_SLICE = 30,
  Term_TermType_SKIP = 70,
  Term_TermType_LIMIT = 71,
  Term_TermType_INDEXES_OF = 87,
  Term_TermType_CONTAINS = 93,
  Term_TermType_GETATTR = 31,
  Term_TermType_KEYS = 94,
  Term_TermType_HAS_FIELDS = 32,
  Term_TermType_WITH_FIELDS = 96,
  Term_TermType_PLUCK = 33,
  Term_TermType_WITHOUT = 34,
  Term_TermType_MERGE = 35,
  Term_TermType_BETWEEN = 36,
  Term_TermType_REDUCE = 37,
  Term_TermType_MAP = 38,
  Term_TermType_FILTER = 39,
  Term_TermType_CONCATMAP = 40,
  Term_TermType_ORDERBY = 41,
  Term_TermType_DISTINCT = 42,
  Term_TermType_COUNT = 43,
  Term_TermType_IS_EMPTY = 86,
  Term_TermType_UNION = 44,
  Term_TermType_NTH = 45,
  Term_TermType_GROUPED_MAP_REDUCE = 46,
  Term_TermType_GROUPBY = 47,
  Term_TermType_INNER_JOIN = 48,
  Term_TermType_OUTER_JOIN = 49,
  Term_TermType_EQ_JOIN = 50,
  Term_TermType_ZIP = 72,
  Term_TermType_INSERT_AT = 82,
  Term_TermType_DELETE_AT = 83,
  Term_TermType_CHANGE_AT = 84,
  Term_TermType_SPLICE_AT = 85,
  Term_TermType_COERCE_TO = 51,
  Term_TermType_TYPEOF = 52,
  Term_TermType_UPDATE = 53,
  Term_TermType_DELETE = 54,
  Term_TermType_REPLACE = 55,
  Term_TermType_INSERT = 56,
  Term_TermType_DB_CREATE = 57,
  Term_TermType_DB_DROP = 58,
  Term_TermType_DB_LIST = 59,
  Term_TermType_TABLE_CREATE = 60,
  Term_TermType_TABLE_DROP = 61,
  Term_TermType_TABLE_LIST = 62,
  Term_TermType_INDEX_CREATE = 75,
  Term_TermType_INDEX_DROP = 76,
  Term_TermType_INDEX_LIST = 77,
  Term_TermType_FUNCALL = 64,
  Term_TermType_BRANCH = 65,
  Term_TermType_ANY = 66,
  Term_TermType_ALL = 67,
  Term_TermType_FOREACH = 68,
  Term_TermType_FUNC = 69,
  Term_TermType_ASC = 73,
  Term_TermType_DESC = 74,
  Term_TermType_INFO = 79,
  Term_TermType_MATCH = 97,
  Term_TermType_SAMPLE = 81,
  Term_TermType_DEFAULT = 92
};
bool Term_TermType_IsValid(int value);
const Term_TermType Term_TermType_TermType_MIN = Term_TermType_DATUM;
const Term_TermType Term_TermType_TermType_MAX = Term_TermType_MATCH;
const int Term_TermType_TermType_ARRAYSIZE = Term_TermType_TermType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Term_TermType_descriptor();
inline const ::std::string& Term_TermType_Name(Term_TermType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Term_TermType_descriptor(), value);
}
inline bool Term_TermType_Parse(
    const ::std::string& name, Term_TermType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Term_TermType>(
    Term_TermType_descriptor(), name, value);
}
// ===================================================================

class VersionDummy : public ::google::protobuf::Message {
 public:
  VersionDummy();
  virtual ~VersionDummy();
  
  VersionDummy(const VersionDummy& from);
  
  inline VersionDummy& operator=(const VersionDummy& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionDummy& default_instance();
  
  void Swap(VersionDummy* other);
  
  // implements Message ----------------------------------------------
  
  VersionDummy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VersionDummy& from);
  void MergeFrom(const VersionDummy& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef VersionDummy_Version Version;
  static const Version V0_1 = VersionDummy_Version_V0_1;
  static const Version V0_2 = VersionDummy_Version_V0_2;
  static inline bool Version_IsValid(int value) {
    return VersionDummy_Version_IsValid(value);
  }
  static const Version Version_MIN =
    VersionDummy_Version_Version_MIN;
  static const Version Version_MAX =
    VersionDummy_Version_Version_MAX;
  static const int Version_ARRAYSIZE =
    VersionDummy_Version_Version_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Version_descriptor() {
    return VersionDummy_Version_descriptor();
  }
  static inline const ::std::string& Version_Name(Version value) {
    return VersionDummy_Version_Name(value);
  }
  static inline bool Version_Parse(const ::std::string& name,
      Version* value) {
    return VersionDummy_Version_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // @@protoc_insertion_point(class_scope:VersionDummy)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];
  
  friend void  protobuf_AddDesc_ql2_2eproto();
  friend void protobuf_AssignDesc_ql2_2eproto();
  friend void protobuf_ShutdownFile_ql2_2eproto();
  
  void InitAsDefaultInstance();
  static VersionDummy* default_instance_;
};
// -------------------------------------------------------------------

class Query_AssocPair : public ::google::protobuf::Message {
 public:
  Query_AssocPair();
  virtual ~Query_AssocPair();
  
  Query_AssocPair(const Query_AssocPair& from);
  
  inline Query_AssocPair& operator=(const Query_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Query_AssocPair& default_instance();
  
  void Swap(Query_AssocPair* other);
  
  // implements Message ----------------------------------------------
  
  Query_AssocPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query_AssocPair& from);
  void MergeFrom(const Query_AssocPair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional .Term val = 2;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 2;
  inline const ::Term& val() const;
  inline ::Term* mutable_val();
  inline ::Term* release_val();
  
  // @@protoc_insertion_point(class_scope:Query.AssocPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val();
  inline void clear_has_val();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::Term* val_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ql2_2eproto();
  friend void protobuf_AssignDesc_ql2_2eproto();
  friend void protobuf_ShutdownFile_ql2_2eproto();
  
  void InitAsDefaultInstance();
  static Query_AssocPair* default_instance_;
};
// -------------------------------------------------------------------

class Query : public ::google::protobuf::Message {
 public:
  Query();
  virtual ~Query();
  
  Query(const Query& from);
  
  inline Query& operator=(const Query& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Query& default_instance();
  
  void Swap(Query* other);
  
  // implements Message ----------------------------------------------
  
  Query* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Query& from);
  void MergeFrom(const Query& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Query_AssocPair AssocPair;
  
  typedef Query_QueryType QueryType;
  static const QueryType START = Query_QueryType_START;
  static const QueryType CONTINUE = Query_QueryType_CONTINUE;
  static const QueryType STOP = Query_QueryType_STOP;
  static inline bool QueryType_IsValid(int value) {
    return Query_QueryType_IsValid(value);
  }
  static const QueryType QueryType_MIN =
    Query_QueryType_QueryType_MIN;
  static const QueryType QueryType_MAX =
    Query_QueryType_QueryType_MAX;
  static const int QueryType_ARRAYSIZE =
    Query_QueryType_QueryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  QueryType_descriptor() {
    return Query_QueryType_descriptor();
  }
  static inline const ::std::string& QueryType_Name(QueryType value) {
    return Query_QueryType_Name(value);
  }
  static inline bool QueryType_Parse(const ::std::string& name,
      QueryType* value) {
    return Query_QueryType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .Query.QueryType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Query_QueryType type() const;
  inline void set_type(::Query_QueryType value);
  
  // optional .Term query = 2;
  inline bool has_query() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 2;
  inline const ::Term& query() const;
  inline ::Term* mutable_query();
  inline ::Term* release_query();
  
  // optional int64 token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline ::google::protobuf::int64 token() const;
  inline void set_token(::google::protobuf::int64 value);
  
  // optional bool OBSOLETE_noreply = 4 [default = false];
  inline bool has_obsolete_noreply() const;
  inline void clear_obsolete_noreply();
  static const int kOBSOLETENoreplyFieldNumber = 4;
  inline bool obsolete_noreply() const;
  inline void set_obsolete_noreply(bool value);
  
  // repeated .Query.AssocPair global_optargs = 6;
  inline int global_optargs_size() const;
  inline void clear_global_optargs();
  static const int kGlobalOptargsFieldNumber = 6;
  inline const ::Query_AssocPair& global_optargs(int index) const;
  inline ::Query_AssocPair* mutable_global_optargs(int index);
  inline ::Query_AssocPair* add_global_optargs();
  inline const ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >&
      global_optargs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >*
      mutable_global_optargs();
  
  // @@protoc_insertion_point(class_scope:Query)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_query();
  inline void clear_has_query();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_obsolete_noreply();
  inline void clear_has_obsolete_noreply();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Term* query_;
  int type_;
  bool obsolete_noreply_;
  ::google::protobuf::int64 token_;
  ::google::protobuf::RepeatedPtrField< ::Query_AssocPair > global_optargs_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_ql2_2eproto();
  friend void protobuf_AssignDesc_ql2_2eproto();
  friend void protobuf_ShutdownFile_ql2_2eproto();
  
  void InitAsDefaultInstance();
  static Query* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::Message {
 public:
  Frame();
  virtual ~Frame();
  
  Frame(const Frame& from);
  
  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Frame& default_instance();
  
  void Swap(Frame* other);
  
  // implements Message ----------------------------------------------
  
  Frame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Frame_FrameType FrameType;
  static const FrameType POS = Frame_FrameType_POS;
  static const FrameType OPT = Frame_FrameType_OPT;
  static inline bool FrameType_IsValid(int value) {
    return Frame_FrameType_IsValid(value);
  }
  static const FrameType FrameType_MIN =
    Frame_FrameType_FrameType_MIN;
  static const FrameType FrameType_MAX =
    Frame_FrameType_FrameType_MAX;
  static const int FrameType_ARRAYSIZE =
    Frame_FrameType_FrameType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FrameType_descriptor() {
    return Frame_FrameType_descriptor();
  }
  static inline const ::std::string& FrameType_Name(FrameType value) {
    return Frame_FrameType_Name(value);
  }
  static inline bool FrameType_Parse(const ::std::string& name,
      FrameType* value) {
    return Frame_FrameType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .Frame.FrameType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Frame_FrameType type() const;
  inline void set_type(::Frame_FrameType value);
  
  // optional int64 pos = 2;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 2;
  inline ::google::protobuf::int64 pos() const;
  inline void set_pos(::google::protobuf::int64 value);
  
  // optional string opt = 3;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 3;
  inline const ::std::string& opt() const;
  inline void set_opt(const ::std::string& value);
  inline void set_opt(const char* value);
  inline void set_opt(const char* value, size_t size);
  inline ::std::string* mutable_opt();
  inline ::std::string* release_opt();
  
  // @@protoc_insertion_point(class_scope:Frame)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_opt();
  inline void clear_has_opt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 pos_;
  ::std::string* opt_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_ql2_2eproto();
  friend void protobuf_AssignDesc_ql2_2eproto();
  friend void protobuf_ShutdownFile_ql2_2eproto();
  
  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// -------------------------------------------------------------------

class Backtrace : public ::google::protobuf::Message {
 public:
  Backtrace();
  virtual ~Backtrace();
  
  Backtrace(const Backtrace& from);
  
  inline Backtrace& operator=(const Backtrace& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Backtrace& default_instance();
  
  void Swap(Backtrace* other);
  
  // implements Message ----------------------------------------------
  
  Backtrace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Backtrace& from);
  void MergeFrom(const Backtrace& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Frame frames = 1;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 1;
  inline const ::Frame& frames(int index) const;
  inline ::Frame* mutable_frames(int index);
  inline ::Frame* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::Frame >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::Frame >*
      mutable_frames();
  
  // @@protoc_insertion_point(class_scope:Backtrace)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Frame > frames_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_ql2_2eproto();
  friend void protobuf_AssignDesc_ql2_2eproto();
  friend void protobuf_ShutdownFile_ql2_2eproto();
  
  void InitAsDefaultInstance();
  static Backtrace* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();
  
  Response(const Response& from);
  
  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();
  
  void Swap(Response* other);
  
  // implements Message ----------------------------------------------
  
  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Response_ResponseType ResponseType;
  static const ResponseType SUCCESS_ATOM = Response_ResponseType_SUCCESS_ATOM;
  static const ResponseType SUCCESS_SEQUENCE = Response_ResponseType_SUCCESS_SEQUENCE;
  static const ResponseType SUCCESS_PARTIAL = Response_ResponseType_SUCCESS_PARTIAL;
  static const ResponseType CLIENT_ERROR = Response_ResponseType_CLIENT_ERROR;
  static const ResponseType COMPILE_ERROR = Response_ResponseType_COMPILE_ERROR;
  static const ResponseType RUNTIME_ERROR = Response_ResponseType_RUNTIME_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return Response_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    Response_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    Response_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    Response_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return Response_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return Response_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return Response_ResponseType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .Response.ResponseType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Response_ResponseType type() const;
  inline void set_type(::Response_ResponseType value);
  
  // optional int64 token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline ::google::protobuf::int64 token() const;
  inline void set_token(::google::protobuf::int64 value);
  
  // repeated .Datum response = 3;
  inline int response_size() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 3;
  inline const ::Datum& response(int index) const;
  inline ::Datum* mutable_response(int index);
  inline ::Datum* add_response();
  inline const ::google::protobuf::RepeatedPtrField< ::Datum >&
      response() const;
  inline ::google::protobuf::RepeatedPtrField< ::Datum >*
      mutable_response();
  
  // optional .Backtrace backtrace = 4;
  inline bool has_backtrace() const;
  inline void clear_backtrace();
  static const int kBacktraceFieldNumber = 4;
  inline const ::Backtrace& backtrace() const;
  inline ::Backtrace* mutable_backtrace();
  inline ::Backtrace* release_backtrace();
  
  // @@protoc_insertion_point(class_scope:Response)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_backtrace();
  inline void clear_has_backtrace();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 token_;
  ::google::protobuf::RepeatedPtrField< ::Datum > response_;
  ::Backtrace* backtrace_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ql2_2eproto();
  friend void protobuf_AssignDesc_ql2_2eproto();
  friend void protobuf_ShutdownFile_ql2_2eproto();
  
  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Datum_AssocPair : public ::google::protobuf::Message {
 public:
  Datum_AssocPair();
  virtual ~Datum_AssocPair();
  
  Datum_AssocPair(const Datum_AssocPair& from);
  
  inline Datum_AssocPair& operator=(const Datum_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Datum_AssocPair& default_instance();
  
  void Swap(Datum_AssocPair* other);
  
  // implements Message ----------------------------------------------
  
  Datum_AssocPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Datum_AssocPair& from);
  void MergeFrom(const Datum_AssocPair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional .Datum val = 2;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 2;
  inline const ::Datum& val() const;
  inline ::Datum* mutable_val();
  inline ::Datum* release_val();
  
  // @@protoc_insertion_point(class_scope:Datum.AssocPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val();
  inline void clear_has_val();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::Datum* val_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ql2_2eproto();
  friend void protobuf_AssignDesc_ql2_2eproto();
  friend void protobuf_ShutdownFile_ql2_2eproto();
  
  void InitAsDefaultInstance();
  static Datum_AssocPair* default_instance_;
};
// -------------------------------------------------------------------

class Datum : public ::google::protobuf::Message {
 public:
  Datum();
  virtual ~Datum();
  
  Datum(const Datum& from);
  
  inline Datum& operator=(const Datum& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Datum& default_instance();
  
  void Swap(Datum* other);
  
  // implements Message ----------------------------------------------
  
  Datum* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Datum& from);
  void MergeFrom(const Datum& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Datum_AssocPair AssocPair;
  
  typedef Datum_DatumType DatumType;
  static const DatumType R_NULL = Datum_DatumType_R_NULL;
  static const DatumType R_BOOL = Datum_DatumType_R_BOOL;
  static const DatumType R_NUM = Datum_DatumType_R_NUM;
  static const DatumType R_STR = Datum_DatumType_R_STR;
  static const DatumType R_ARRAY = Datum_DatumType_R_ARRAY;
  static const DatumType R_OBJECT = Datum_DatumType_R_OBJECT;
  static inline bool DatumType_IsValid(int value) {
    return Datum_DatumType_IsValid(value);
  }
  static const DatumType DatumType_MIN =
    Datum_DatumType_DatumType_MIN;
  static const DatumType DatumType_MAX =
    Datum_DatumType_DatumType_MAX;
  static const int DatumType_ARRAYSIZE =
    Datum_DatumType_DatumType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DatumType_descriptor() {
    return Datum_DatumType_descriptor();
  }
  static inline const ::std::string& DatumType_Name(DatumType value) {
    return Datum_DatumType_Name(value);
  }
  static inline bool DatumType_Parse(const ::std::string& name,
      DatumType* value) {
    return Datum_DatumType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .Datum.DatumType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Datum_DatumType type() const;
  inline void set_type(::Datum_DatumType value);
  
  // optional bool r_bool = 2;
  inline bool has_r_bool() const;
  inline void clear_r_bool();
  static const int kRBoolFieldNumber = 2;
  inline bool r_bool() const;
  inline void set_r_bool(bool value);
  
  // optional double r_num = 3;
  inline bool has_r_num() const;
  inline void clear_r_num();
  static const int kRNumFieldNumber = 3;
  inline double r_num() const;
  inline void set_r_num(double value);
  
  // optional string r_str = 4;
  inline bool has_r_str() const;
  inline void clear_r_str();
  static const int kRStrFieldNumber = 4;
  inline const ::std::string& r_str() const;
  inline void set_r_str(const ::std::string& value);
  inline void set_r_str(const char* value);
  inline void set_r_str(const char* value, size_t size);
  inline ::std::string* mutable_r_str();
  inline ::std::string* release_r_str();
  
  // repeated .Datum r_array = 5;
  inline int r_array_size() const;
  inline void clear_r_array();
  static const int kRArrayFieldNumber = 5;
  inline const ::Datum& r_array(int index) const;
  inline ::Datum* mutable_r_array(int index);
  inline ::Datum* add_r_array();
  inline const ::google::protobuf::RepeatedPtrField< ::Datum >&
      r_array() const;
  inline ::google::protobuf::RepeatedPtrField< ::Datum >*
      mutable_r_array();
  
  // repeated .Datum.AssocPair r_object = 6;
  inline int r_object_size() const;
  inline void clear_r_object();
  static const int kRObjectFieldNumber = 6;
  inline const ::Datum_AssocPair& r_object(int index) const;
  inline ::Datum_AssocPair* mutable_r_object(int index);
  inline ::Datum_AssocPair* add_r_object();
  inline const ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >&
      r_object() const;
  inline ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >*
      mutable_r_object();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Datum)
  // @@protoc_insertion_point(class_scope:Datum)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_r_bool();
  inline void clear_has_r_bool();
  inline void set_has_r_num();
  inline void clear_has_r_num();
  inline void set_has_r_str();
  inline void clear_has_r_str();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int type_;
  bool r_bool_;
  double r_num_;
  ::std::string* r_str_;
  ::google::protobuf::RepeatedPtrField< ::Datum > r_array_;
  ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair > r_object_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_ql2_2eproto();
  friend void protobuf_AssignDesc_ql2_2eproto();
  friend void protobuf_ShutdownFile_ql2_2eproto();
  
  void InitAsDefaultInstance();
  static Datum* default_instance_;
};
// -------------------------------------------------------------------

class Term_AssocPair : public ::google::protobuf::Message {
 public:
  Term_AssocPair();
  virtual ~Term_AssocPair();
  
  Term_AssocPair(const Term_AssocPair& from);
  
  inline Term_AssocPair& operator=(const Term_AssocPair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Term_AssocPair& default_instance();
  
  void Swap(Term_AssocPair* other);
  
  // implements Message ----------------------------------------------
  
  Term_AssocPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Term_AssocPair& from);
  void MergeFrom(const Term_AssocPair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional .Term val = 2;
  inline bool has_val() const;
  inline void clear_val();
  static const int kValFieldNumber = 2;
  inline const ::Term& val() const;
  inline ::Term* mutable_val();
  inline ::Term* release_val();
  
  // @@protoc_insertion_point(class_scope:Term.AssocPair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_val();
  inline void clear_has_val();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::Term* val_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_ql2_2eproto();
  friend void protobuf_AssignDesc_ql2_2eproto();
  friend void protobuf_ShutdownFile_ql2_2eproto();
  
  void InitAsDefaultInstance();
  static Term_AssocPair* default_instance_;
};
// -------------------------------------------------------------------

class Term : public ::google::protobuf::Message {
 public:
  Term();
  virtual ~Term();
  
  Term(const Term& from);
  
  inline Term& operator=(const Term& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Term& default_instance();
  
  void Swap(Term* other);
  
  // implements Message ----------------------------------------------
  
  Term* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Term& from);
  void MergeFrom(const Term& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Term_AssocPair AssocPair;
  
  typedef Term_TermType TermType;
  static const TermType DATUM = Term_TermType_DATUM;
  static const TermType MAKE_ARRAY = Term_TermType_MAKE_ARRAY;
  static const TermType MAKE_OBJ = Term_TermType_MAKE_OBJ;
  static const TermType VAR = Term_TermType_VAR;
  static const TermType JAVASCRIPT = Term_TermType_JAVASCRIPT;
  static const TermType ERROR = Term_TermType_ERROR;
  static const TermType IMPLICIT_VAR = Term_TermType_IMPLICIT_VAR;
  static const TermType DB = Term_TermType_DB;
  static const TermType TABLE = Term_TermType_TABLE;
  static const TermType GET = Term_TermType_GET;
  static const TermType GET_ALL = Term_TermType_GET_ALL;
  static const TermType EQ = Term_TermType_EQ;
  static const TermType NE = Term_TermType_NE;
  static const TermType LT = Term_TermType_LT;
  static const TermType LE = Term_TermType_LE;
  static const TermType GT = Term_TermType_GT;
  static const TermType GE = Term_TermType_GE;
  static const TermType NOT = Term_TermType_NOT;
  static const TermType ADD = Term_TermType_ADD;
  static const TermType SUB = Term_TermType_SUB;
  static const TermType MUL = Term_TermType_MUL;
  static const TermType DIV = Term_TermType_DIV;
  static const TermType MOD = Term_TermType_MOD;
  static const TermType APPEND = Term_TermType_APPEND;
  static const TermType PREPEND = Term_TermType_PREPEND;
  static const TermType DIFFERENCE = Term_TermType_DIFFERENCE;
  static const TermType SET_INSERT = Term_TermType_SET_INSERT;
  static const TermType SET_INTERSECTION = Term_TermType_SET_INTERSECTION;
  static const TermType SET_UNION = Term_TermType_SET_UNION;
  static const TermType SET_DIFFERENCE = Term_TermType_SET_DIFFERENCE;
  static const TermType SLICE = Term_TermType_SLICE;
  static const TermType SKIP = Term_TermType_SKIP;
  static const TermType LIMIT = Term_TermType_LIMIT;
  static const TermType INDEXES_OF = Term_TermType_INDEXES_OF;
  static const TermType CONTAINS = Term_TermType_CONTAINS;
  static const TermType GETATTR = Term_TermType_GETATTR;
  static const TermType KEYS = Term_TermType_KEYS;
  static const TermType HAS_FIELDS = Term_TermType_HAS_FIELDS;
  static const TermType WITH_FIELDS = Term_TermType_WITH_FIELDS;
  static const TermType PLUCK = Term_TermType_PLUCK;
  static const TermType WITHOUT = Term_TermType_WITHOUT;
  static const TermType MERGE = Term_TermType_MERGE;
  static const TermType BETWEEN = Term_TermType_BETWEEN;
  static const TermType REDUCE = Term_TermType_REDUCE;
  static const TermType MAP = Term_TermType_MAP;
  static const TermType FILTER = Term_TermType_FILTER;
  static const TermType CONCATMAP = Term_TermType_CONCATMAP;
  static const TermType ORDERBY = Term_TermType_ORDERBY;
  static const TermType DISTINCT = Term_TermType_DISTINCT;
  static const TermType COUNT = Term_TermType_COUNT;
  static const TermType IS_EMPTY = Term_TermType_IS_EMPTY;
  static const TermType UNION = Term_TermType_UNION;
  static const TermType NTH = Term_TermType_NTH;
  static const TermType GROUPED_MAP_REDUCE = Term_TermType_GROUPED_MAP_REDUCE;
  static const TermType GROUPBY = Term_TermType_GROUPBY;
  static const TermType INNER_JOIN = Term_TermType_INNER_JOIN;
  static const TermType OUTER_JOIN = Term_TermType_OUTER_JOIN;
  static const TermType EQ_JOIN = Term_TermType_EQ_JOIN;
  static const TermType ZIP = Term_TermType_ZIP;
  static const TermType INSERT_AT = Term_TermType_INSERT_AT;
  static const TermType DELETE_AT = Term_TermType_DELETE_AT;
  static const TermType CHANGE_AT = Term_TermType_CHANGE_AT;
  static const TermType SPLICE_AT = Term_TermType_SPLICE_AT;
  static const TermType COERCE_TO = Term_TermType_COERCE_TO;
  static const TermType TYPEOF = Term_TermType_TYPEOF;
  static const TermType UPDATE = Term_TermType_UPDATE;
  static const TermType DELETE = Term_TermType_DELETE;
  static const TermType REPLACE = Term_TermType_REPLACE;
  static const TermType INSERT = Term_TermType_INSERT;
  static const TermType DB_CREATE = Term_TermType_DB_CREATE;
  static const TermType DB_DROP = Term_TermType_DB_DROP;
  static const TermType DB_LIST = Term_TermType_DB_LIST;
  static const TermType TABLE_CREATE = Term_TermType_TABLE_CREATE;
  static const TermType TABLE_DROP = Term_TermType_TABLE_DROP;
  static const TermType TABLE_LIST = Term_TermType_TABLE_LIST;
  static const TermType INDEX_CREATE = Term_TermType_INDEX_CREATE;
  static const TermType INDEX_DROP = Term_TermType_INDEX_DROP;
  static const TermType INDEX_LIST = Term_TermType_INDEX_LIST;
  static const TermType FUNCALL = Term_TermType_FUNCALL;
  static const TermType BRANCH = Term_TermType_BRANCH;
  static const TermType ANY = Term_TermType_ANY;
  static const TermType ALL = Term_TermType_ALL;
  static const TermType FOREACH = Term_TermType_FOREACH;
  static const TermType FUNC = Term_TermType_FUNC;
  static const TermType ASC = Term_TermType_ASC;
  static const TermType DESC = Term_TermType_DESC;
  static const TermType INFO = Term_TermType_INFO;
  static const TermType MATCH = Term_TermType_MATCH;
  static const TermType SAMPLE = Term_TermType_SAMPLE;
  static const TermType DEFAULT = Term_TermType_DEFAULT;
  static inline bool TermType_IsValid(int value) {
    return Term_TermType_IsValid(value);
  }
  static const TermType TermType_MIN =
    Term_TermType_TermType_MIN;
  static const TermType TermType_MAX =
    Term_TermType_TermType_MAX;
  static const int TermType_ARRAYSIZE =
    Term_TermType_TermType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TermType_descriptor() {
    return Term_TermType_descriptor();
  }
  static inline const ::std::string& TermType_Name(TermType value) {
    return Term_TermType_Name(value);
  }
  static inline bool TermType_Parse(const ::std::string& name,
      TermType* value) {
    return Term_TermType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .Term.TermType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::Term_TermType type() const;
  inline void set_type(::Term_TermType value);
  
  // optional .Datum datum = 2;
  inline bool has_datum() const;
  inline void clear_datum();
  static const int kDatumFieldNumber = 2;
  inline const ::Datum& datum() const;
  inline ::Datum* mutable_datum();
  inline ::Datum* release_datum();
  
  // repeated .Term args = 3;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 3;
  inline const ::Term& args(int index) const;
  inline ::Term* mutable_args(int index);
  inline ::Term* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::Term >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::Term >*
      mutable_args();
  
  // repeated .Term.AssocPair optargs = 4;
  inline int optargs_size() const;
  inline void clear_optargs();
  static const int kOptargsFieldNumber = 4;
  inline const ::Term_AssocPair& optargs(int index) const;
  inline ::Term_AssocPair* mutable_optargs(int index);
  inline ::Term_AssocPair* add_optargs();
  inline const ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >&
      optargs() const;
  inline ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >*
      mutable_optargs();
  
  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Term)
  // @@protoc_insertion_point(class_scope:Term)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_datum();
  inline void clear_has_datum();
  
  ::google::protobuf::internal::ExtensionSet _extensions_;
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Datum* datum_;
  ::google::protobuf::RepeatedPtrField< ::Term > args_;
  ::google::protobuf::RepeatedPtrField< ::Term_AssocPair > optargs_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_ql2_2eproto();
  friend void protobuf_AssignDesc_ql2_2eproto();
  friend void protobuf_ShutdownFile_ql2_2eproto();
  
  void InitAsDefaultInstance();
  static Term* default_instance_;
};
// ===================================================================


// ===================================================================

// VersionDummy

// -------------------------------------------------------------------

// Query_AssocPair

// optional string key = 1;
inline bool Query_AssocPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Query_AssocPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Query_AssocPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Query_AssocPair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Query_AssocPair::key() const {
  return *key_;
}
inline void Query_AssocPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Query_AssocPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Query_AssocPair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Query_AssocPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Query_AssocPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Term val = 2;
inline bool Query_AssocPair::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Query_AssocPair::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Query_AssocPair::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Query_AssocPair::clear_val() {
  if (val_ != NULL) val_->::Term::Clear();
  clear_has_val();
}
inline const ::Term& Query_AssocPair::val() const {
  return val_ != NULL ? *val_ : *default_instance_->val_;
}
inline ::Term* Query_AssocPair::mutable_val() {
  set_has_val();
  if (val_ == NULL) val_ = new ::Term;
  return val_;
}
inline ::Term* Query_AssocPair::release_val() {
  clear_has_val();
  ::Term* temp = val_;
  val_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Query

// optional .Query.QueryType type = 1;
inline bool Query::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Query::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Query::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Query::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Query_QueryType Query::type() const {
  return static_cast< ::Query_QueryType >(type_);
}
inline void Query::set_type(::Query_QueryType value) {
  GOOGLE_DCHECK(::Query_QueryType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Term query = 2;
inline bool Query::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Query::set_has_query() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Query::clear_has_query() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Query::clear_query() {
  if (query_ != NULL) query_->::Term::Clear();
  clear_has_query();
}
inline const ::Term& Query::query() const {
  return query_ != NULL ? *query_ : *default_instance_->query_;
}
inline ::Term* Query::mutable_query() {
  set_has_query();
  if (query_ == NULL) query_ = new ::Term;
  return query_;
}
inline ::Term* Query::release_query() {
  clear_has_query();
  ::Term* temp = query_;
  query_ = NULL;
  return temp;
}

// optional int64 token = 3;
inline bool Query::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Query::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Query::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Query::clear_token() {
  token_ = GOOGLE_LONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::int64 Query::token() const {
  return token_;
}
inline void Query::set_token(::google::protobuf::int64 value) {
  set_has_token();
  token_ = value;
}

// optional bool OBSOLETE_noreply = 4 [default = false];
inline bool Query::has_obsolete_noreply() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Query::set_has_obsolete_noreply() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Query::clear_has_obsolete_noreply() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Query::clear_obsolete_noreply() {
  obsolete_noreply_ = false;
  clear_has_obsolete_noreply();
}
inline bool Query::obsolete_noreply() const {
  return obsolete_noreply_;
}
inline void Query::set_obsolete_noreply(bool value) {
  set_has_obsolete_noreply();
  obsolete_noreply_ = value;
}

// repeated .Query.AssocPair global_optargs = 6;
inline int Query::global_optargs_size() const {
  return global_optargs_.size();
}
inline void Query::clear_global_optargs() {
  global_optargs_.Clear();
}
inline const ::Query_AssocPair& Query::global_optargs(int index) const {
  return global_optargs_.Get(index);
}
inline ::Query_AssocPair* Query::mutable_global_optargs(int index) {
  return global_optargs_.Mutable(index);
}
inline ::Query_AssocPair* Query::add_global_optargs() {
  return global_optargs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >&
Query::global_optargs() const {
  return global_optargs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Query_AssocPair >*
Query::mutable_global_optargs() {
  return &global_optargs_;
}

// -------------------------------------------------------------------

// Frame

// optional .Frame.FrameType type = 1;
inline bool Frame::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Frame_FrameType Frame::type() const {
  return static_cast< ::Frame_FrameType >(type_);
}
inline void Frame::set_type(::Frame_FrameType value) {
  GOOGLE_DCHECK(::Frame_FrameType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 pos = 2;
inline bool Frame::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame::clear_pos() {
  pos_ = GOOGLE_LONGLONG(0);
  clear_has_pos();
}
inline ::google::protobuf::int64 Frame::pos() const {
  return pos_;
}
inline void Frame::set_pos(::google::protobuf::int64 value) {
  set_has_pos();
  pos_ = value;
}

// optional string opt = 3;
inline bool Frame::has_opt() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame::set_has_opt() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame::clear_has_opt() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame::clear_opt() {
  if (opt_ != &::google::protobuf::internal::kEmptyString) {
    opt_->clear();
  }
  clear_has_opt();
}
inline const ::std::string& Frame::opt() const {
  return *opt_;
}
inline void Frame::set_opt(const ::std::string& value) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(value);
}
inline void Frame::set_opt(const char* value) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(value);
}
inline void Frame::set_opt(const char* value, size_t size) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Frame::mutable_opt() {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  return opt_;
}
inline ::std::string* Frame::release_opt() {
  clear_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt_;
    opt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Backtrace

// repeated .Frame frames = 1;
inline int Backtrace::frames_size() const {
  return frames_.size();
}
inline void Backtrace::clear_frames() {
  frames_.Clear();
}
inline const ::Frame& Backtrace::frames(int index) const {
  return frames_.Get(index);
}
inline ::Frame* Backtrace::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::Frame* Backtrace::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Frame >&
Backtrace::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::Frame >*
Backtrace::mutable_frames() {
  return &frames_;
}

// -------------------------------------------------------------------

// Response

// optional .Response.ResponseType type = 1;
inline bool Response::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Response_ResponseType Response::type() const {
  return static_cast< ::Response_ResponseType >(type_);
}
inline void Response::set_type(::Response_ResponseType value) {
  GOOGLE_DCHECK(::Response_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 token = 2;
inline bool Response::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_token() {
  token_ = GOOGLE_LONGLONG(0);
  clear_has_token();
}
inline ::google::protobuf::int64 Response::token() const {
  return token_;
}
inline void Response::set_token(::google::protobuf::int64 value) {
  set_has_token();
  token_ = value;
}

// repeated .Datum response = 3;
inline int Response::response_size() const {
  return response_.size();
}
inline void Response::clear_response() {
  response_.Clear();
}
inline const ::Datum& Response::response(int index) const {
  return response_.Get(index);
}
inline ::Datum* Response::mutable_response(int index) {
  return response_.Mutable(index);
}
inline ::Datum* Response::add_response() {
  return response_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Datum >&
Response::response() const {
  return response_;
}
inline ::google::protobuf::RepeatedPtrField< ::Datum >*
Response::mutable_response() {
  return &response_;
}

// optional .Backtrace backtrace = 4;
inline bool Response::has_backtrace() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_backtrace() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_backtrace() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_backtrace() {
  if (backtrace_ != NULL) backtrace_->::Backtrace::Clear();
  clear_has_backtrace();
}
inline const ::Backtrace& Response::backtrace() const {
  return backtrace_ != NULL ? *backtrace_ : *default_instance_->backtrace_;
}
inline ::Backtrace* Response::mutable_backtrace() {
  set_has_backtrace();
  if (backtrace_ == NULL) backtrace_ = new ::Backtrace;
  return backtrace_;
}
inline ::Backtrace* Response::release_backtrace() {
  clear_has_backtrace();
  ::Backtrace* temp = backtrace_;
  backtrace_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Datum_AssocPair

// optional string key = 1;
inline bool Datum_AssocPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Datum_AssocPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Datum_AssocPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Datum_AssocPair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Datum_AssocPair::key() const {
  return *key_;
}
inline void Datum_AssocPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Datum_AssocPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Datum_AssocPair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Datum_AssocPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Datum_AssocPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Datum val = 2;
inline bool Datum_AssocPair::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Datum_AssocPair::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Datum_AssocPair::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Datum_AssocPair::clear_val() {
  if (val_ != NULL) val_->::Datum::Clear();
  clear_has_val();
}
inline const ::Datum& Datum_AssocPair::val() const {
  return val_ != NULL ? *val_ : *default_instance_->val_;
}
inline ::Datum* Datum_AssocPair::mutable_val() {
  set_has_val();
  if (val_ == NULL) val_ = new ::Datum;
  return val_;
}
inline ::Datum* Datum_AssocPair::release_val() {
  clear_has_val();
  ::Datum* temp = val_;
  val_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Datum

// optional .Datum.DatumType type = 1;
inline bool Datum::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Datum::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Datum::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Datum::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Datum_DatumType Datum::type() const {
  return static_cast< ::Datum_DatumType >(type_);
}
inline void Datum::set_type(::Datum_DatumType value) {
  GOOGLE_DCHECK(::Datum_DatumType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional bool r_bool = 2;
inline bool Datum::has_r_bool() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Datum::set_has_r_bool() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Datum::clear_has_r_bool() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Datum::clear_r_bool() {
  r_bool_ = false;
  clear_has_r_bool();
}
inline bool Datum::r_bool() const {
  return r_bool_;
}
inline void Datum::set_r_bool(bool value) {
  set_has_r_bool();
  r_bool_ = value;
}

// optional double r_num = 3;
inline bool Datum::has_r_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Datum::set_has_r_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Datum::clear_has_r_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Datum::clear_r_num() {
  r_num_ = 0;
  clear_has_r_num();
}
inline double Datum::r_num() const {
  return r_num_;
}
inline void Datum::set_r_num(double value) {
  set_has_r_num();
  r_num_ = value;
}

// optional string r_str = 4;
inline bool Datum::has_r_str() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Datum::set_has_r_str() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Datum::clear_has_r_str() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Datum::clear_r_str() {
  if (r_str_ != &::google::protobuf::internal::kEmptyString) {
    r_str_->clear();
  }
  clear_has_r_str();
}
inline const ::std::string& Datum::r_str() const {
  return *r_str_;
}
inline void Datum::set_r_str(const ::std::string& value) {
  set_has_r_str();
  if (r_str_ == &::google::protobuf::internal::kEmptyString) {
    r_str_ = new ::std::string;
  }
  r_str_->assign(value);
}
inline void Datum::set_r_str(const char* value) {
  set_has_r_str();
  if (r_str_ == &::google::protobuf::internal::kEmptyString) {
    r_str_ = new ::std::string;
  }
  r_str_->assign(value);
}
inline void Datum::set_r_str(const char* value, size_t size) {
  set_has_r_str();
  if (r_str_ == &::google::protobuf::internal::kEmptyString) {
    r_str_ = new ::std::string;
  }
  r_str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Datum::mutable_r_str() {
  set_has_r_str();
  if (r_str_ == &::google::protobuf::internal::kEmptyString) {
    r_str_ = new ::std::string;
  }
  return r_str_;
}
inline ::std::string* Datum::release_r_str() {
  clear_has_r_str();
  if (r_str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = r_str_;
    r_str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .Datum r_array = 5;
inline int Datum::r_array_size() const {
  return r_array_.size();
}
inline void Datum::clear_r_array() {
  r_array_.Clear();
}
inline const ::Datum& Datum::r_array(int index) const {
  return r_array_.Get(index);
}
inline ::Datum* Datum::mutable_r_array(int index) {
  return r_array_.Mutable(index);
}
inline ::Datum* Datum::add_r_array() {
  return r_array_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Datum >&
Datum::r_array() const {
  return r_array_;
}
inline ::google::protobuf::RepeatedPtrField< ::Datum >*
Datum::mutable_r_array() {
  return &r_array_;
}

// repeated .Datum.AssocPair r_object = 6;
inline int Datum::r_object_size() const {
  return r_object_.size();
}
inline void Datum::clear_r_object() {
  r_object_.Clear();
}
inline const ::Datum_AssocPair& Datum::r_object(int index) const {
  return r_object_.Get(index);
}
inline ::Datum_AssocPair* Datum::mutable_r_object(int index) {
  return r_object_.Mutable(index);
}
inline ::Datum_AssocPair* Datum::add_r_object() {
  return r_object_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >&
Datum::r_object() const {
  return r_object_;
}
inline ::google::protobuf::RepeatedPtrField< ::Datum_AssocPair >*
Datum::mutable_r_object() {
  return &r_object_;
}

// -------------------------------------------------------------------

// Term_AssocPair

// optional string key = 1;
inline bool Term_AssocPair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Term_AssocPair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Term_AssocPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Term_AssocPair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Term_AssocPair::key() const {
  return *key_;
}
inline void Term_AssocPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Term_AssocPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Term_AssocPair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Term_AssocPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Term_AssocPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .Term val = 2;
inline bool Term_AssocPair::has_val() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Term_AssocPair::set_has_val() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Term_AssocPair::clear_has_val() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Term_AssocPair::clear_val() {
  if (val_ != NULL) val_->::Term::Clear();
  clear_has_val();
}
inline const ::Term& Term_AssocPair::val() const {
  return val_ != NULL ? *val_ : *default_instance_->val_;
}
inline ::Term* Term_AssocPair::mutable_val() {
  set_has_val();
  if (val_ == NULL) val_ = new ::Term;
  return val_;
}
inline ::Term* Term_AssocPair::release_val() {
  clear_has_val();
  ::Term* temp = val_;
  val_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Term

// optional .Term.TermType type = 1;
inline bool Term::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Term::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Term::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Term::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::Term_TermType Term::type() const {
  return static_cast< ::Term_TermType >(type_);
}
inline void Term::set_type(::Term_TermType value) {
  GOOGLE_DCHECK(::Term_TermType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .Datum datum = 2;
inline bool Term::has_datum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Term::set_has_datum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Term::clear_has_datum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Term::clear_datum() {
  if (datum_ != NULL) datum_->::Datum::Clear();
  clear_has_datum();
}
inline const ::Datum& Term::datum() const {
  return datum_ != NULL ? *datum_ : *default_instance_->datum_;
}
inline ::Datum* Term::mutable_datum() {
  set_has_datum();
  if (datum_ == NULL) datum_ = new ::Datum;
  return datum_;
}
inline ::Datum* Term::release_datum() {
  clear_has_datum();
  ::Datum* temp = datum_;
  datum_ = NULL;
  return temp;
}

// repeated .Term args = 3;
inline int Term::args_size() const {
  return args_.size();
}
inline void Term::clear_args() {
  args_.Clear();
}
inline const ::Term& Term::args(int index) const {
  return args_.Get(index);
}
inline ::Term* Term::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::Term* Term::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Term >&
Term::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::Term >*
Term::mutable_args() {
  return &args_;
}

// repeated .Term.AssocPair optargs = 4;
inline int Term::optargs_size() const {
  return optargs_.size();
}
inline void Term::clear_optargs() {
  optargs_.Clear();
}
inline const ::Term_AssocPair& Term::optargs(int index) const {
  return optargs_.Get(index);
}
inline ::Term_AssocPair* Term::mutable_optargs(int index) {
  return optargs_.Mutable(index);
}
inline ::Term_AssocPair* Term::add_optargs() {
  return optargs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >&
Term::optargs() const {
  return optargs_;
}
inline ::google::protobuf::RepeatedPtrField< ::Term_AssocPair >*
Term::mutable_optargs() {
  return &optargs_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VersionDummy_Version>() {
  return ::VersionDummy_Version_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Query_QueryType>() {
  return ::Query_QueryType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Frame_FrameType>() {
  return ::Frame_FrameType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Response_ResponseType>() {
  return ::Response_ResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Datum_DatumType>() {
  return ::Datum_DatumType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Term_TermType>() {
  return ::Term_TermType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ql2_2eproto__INCLUDED
